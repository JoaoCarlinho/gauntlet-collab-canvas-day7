# Railway-optimized Dockerfile with fallback images
# This Dockerfile handles Docker Hub connectivity issues with multiple fallback strategies

# Try multiple base images in order of preference
FROM node:18-alpine AS builder

# If the above fails, Railway will try these alternatives:
# FROM ghcr.io/node:18-alpine AS builder
# FROM public.ecr.aws/docker/library/node:18-alpine AS builder
# FROM node:18-slim AS builder

# Set working directory
WORKDIR /app

# Install curl for health checks and debugging
RUN apk add --no-cache curl

# Copy package files first for better layer caching
COPY package*.json ./

# Install dependencies with retry mechanism
RUN for i in 1 2 3; do \
        npm ci --frozen-lockfile --prefer-offline --no-audit && break || \
        (echo "Attempt $i failed, retrying..." && sleep 5); \
    done

# Copy source code
COPY . .

# Build the application
RUN npm run build:railway

# Production stage with fallback images
FROM node:18-alpine AS runner

# If the above fails, Railway will try these alternatives:
# FROM ghcr.io/node:18-alpine AS runner
# FROM public.ecr.aws/docker/library/node:18-alpine AS runner
# FROM node:18-slim AS runner

# Set working directory
WORKDIR /app

# Install serve and curl
RUN npm install -g serve && \
    apk add --no-cache curl

# Copy built application from builder stage
COPY --from=builder /app/dist ./dist

# Expose port
EXPOSE 3000

# Set environment variables
ENV NODE_ENV=production
ENV PORT=3000

# Health check using curl (more reliable than Node.js in Alpine)
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
  CMD curl -f http://localhost:3000/ || exit 1

# Start the application
CMD ["serve", "-s", "dist", "-l", "3000"]
